
LAS CUATRO AREAS DE INTRODUCCION 

Nos sentraremosen como git ve el mundo , en como piensa de los datos y flujo de trabajo , que sucede cuando 
realizamos operaciones comunes como verificar una confirmacion o restablecer una rama , hablaremos de como datos 
y como hacer cosas interesantes con ellos , hay  tres partes importantes que se dividen de la siguiente manera,

1 Conceptos claves en un proyecto de git
2 operaciones basicas de git mueven los datos atravez de las cuatro AREAS
3 git reset 
4 las cuatro areas herramientas avanzadas 

Despues tendremos una segunda parte que son de la siguiente manera

dos modulos que traten de la historia del proyecto 
el primero es sobre el historial de navegacion , explorar el pasado si se desea 
por ultimo modulo se destaca por si solo , se trata mas de trabajo en equipo 

LINEAS DE COMANDOS

las lineas de comando es nuestro amigo , por lo que se nos hace facil aprender git 

areas en las que se trabajara en git 

1 directorio de proyectos, sistema de archivos en el area de trabajo es donde se guarda los archivos y las carpetas actuales
2 Repositorio , es donde usamos git y contiene toda la historia del proyecto cuando "commit" cosas van aqui , entre 
3 el index : estas dos areas hay una llamada index , que se encuentra en la mitad de estas dos , es donde se colocan los archivos antes de una confirmacion "commit"
es escencial entender como funciona el index  
4 stash: es un area de almacenamiento temporal llamada stash, no es tan importante como las otras tres pero es util .

si de verdad queremos entender Gir hay dos preguntas importantes que nos debemos hacer y son las siguientes;

1 como mueve este comando los datos atravez de las cuatro areas 
2 que hace este comando especificamente al repositorio 

no importa que tan confuso se vea un comando siempre y cuando pueda responder estas dos preguntas ,

EL AREA DE TRABAJO 

*El area de trabajo  , debemos entender las partes internas de git antes de continuar 
debemos entender el directorio del proyecto en su sistema de archivos , aqui es donde trabaja edita sus archivos , pruebe su codigo etc 
aca encontraremos archivos y carpetas , si queremos cambiar un archivo siplemente lo editariomoas o moveriamos 
todo esto ocurre en el area de trabajo. 

para git el area de trabajo es algo muy temporal , por ello es importante no asumir un archivo que esta guardado antes de de realizar una confirmacion para 
que los datos se guarden al repositorio.

el repositorio esta en la carpeta .git , las bases mas importantes se encuentran en una carpeta llamada object,
hay algunos tipos diferentes de objectos en la base de datos , algunos objetos representan el contenido de un archivo
algun momento de la historia del proyecto estos objetos se llaman blob  , y luego hay otro objetos llamados arboles que representan carpetas
en el proyecto , y tambien hay compromisos "commit", todos estos objetos son inmutables se pueden crear y eliminar pero nunca 
se pueden cambiar , estso objetos estan unidos entre si en una estructura unida que representa el historial del proyecto ,
cada confirmacion apunta a un grafico de blobs y arboles que representan sus archivos y carpetas .

cada confirmacion es como una instantanea de su area de trabajo en un determinado momento , tambien dos confirmaciones pueden compartir los mismos objetos entre si
esta es la forma en que git almacena los cambios en archivosy directorios.

En la historio de un proyecto de git cada confirmacion apunta a sus confirmaciones principales , es decir si te refieres a alguna confirmacion ,te refieres tambien 
a las que estan añadidas a ellas otras confirmaciones, las confirmaciones son instantanes , esto hace parte de una porcion de historia de su proyecto 

las ramas son una referencia a una confirmacion , y debido a que hace referencia a la confirmacion y las confirmaciones estan vinculadas entre si 
para formar un historial , la rama es basicamente el punto de entrada a un historial de confirmaciones y puede tener multiples ramas que son 
multiples sectores de la historia .

finalmente hay un puntero especial llamado HEAD solo puede haber una cabeza y esta apunta a la rama actual y la rama apunta a una confirmacion actual , 
aveces puedes realizar operaciones que resultan en confirmaciones a las que no se pueden acceder desde ninguna rama , es decir si elimino una rama las confirmaciones 
que estaban dentro de ella quedan en el limbo inalcansables , por lo que no hay una rama que las señale directemente ni indirectamente , entonces lo que hara git sera 
eliminar esas confirmaciones .

EL INDEX "Indice"

El index es una cosa muy peculiar , ya que es exclusivo de git ya que es el unico sistema de control de versiones que le permite modificar el index directamente
ya que es algo que se interpone entre el area de trabajo y el repositorio , porque generalmente no mueve los datos del area de trabajo al repositorio
va al index, es por eso que se llama area de preparacion , se puede organizar los cambios agregandolos desde el area de trabajo al Indice
y luego se confirman los cambios del indice al repositorio .

cuando decimos  que hay un archivo en el repositorio ,generalmene se refiere a algo mas especifico , quiere decir que el archivo esta en la confirmacion actual de repositorio 
el repositorio tambien contiene mas cosas, basicamente toda la historia del proyecto .

si observamos dentro de la carpet .git encontraremos otra que es index es un archivo binario, por lo que no se puede abrir con un editor de texto ,  por lo general el index para 
y confirma al repositorio , pero en este caso imaginaremos que el index no quedara vacio , al contrario tendra los mismo datos que el repositorio .

utilicemos git diff, este comando nos ayuda a mirar las diferencias entre estas dos areas , una cosa que es un poco contradictoria es que si usamos git diff 
es que si se usa git diff sin ningun argumento comparara el area de trabajo con el index,  entonces nos mostrara que esta bacio .

por lo general usamos git status para ver lo que vamos a comprometer , pero como queremos mirar que es lo que se va a comprometer entre el index y el repositorio usamos 
-git diff --cached , esto lo que hace es alinear el indice y la ultima confirmacion , 

LAS CUATRO AREAS DEL FLUJO DE TRABAJO 

Conceptos Basicos 

para esto vamos a agragar informacion al documento , al terminar revisaremos git status , nos muestra el archivo de color rojo 
ahora para agregar el archivo a index git add .  el archivo se pasa al area de trabajo index , donde el estado de git me dice que el archivo 
se modifica y organiza llamemos el comando " git diff" no ve diferencias,el area de trabajo y el index estan alineados , pero si comparamos el index 
y el repositorio con "git diff --cached "se podran ver los cambios , estan listos para entrar en el proximo commit 

entonces con estas operaciones movimos los datos de izquierda a derecha, del area de trabajo al index, y luego al repositorio 
si miramos con el comando git diff y git diff --cached estaremos en estado limpio nuevamente , al observar el ultimo commit , podremos ver 
que creo una confirmacion y nuevos objectos , en ese orden de ideas commit mueve datos y cambia el repositorio 

MOVER DATOS A LA IZQUIERDA

se te ocurre un comando que mueva datos a la otra direccion desde el repositorio y es "checkout " lo que hace este comando es mover HEAD a otra rama 
y lo segundo que hace es tomar datos de la nueva confirmacion actual y copia esos datos del repositorio al area de trabajo y al index , entonces cambia el 
repositorio y mueve los datos en segundo lugar , para ello veamos las diferencias que hay de una rama aa otra de la siguiente manera 

-git diff nombre de la rama y la otra rama seguido , nos mostrar los cambios que se han hecho, entonces que pasa 
si revisamos la otra rama con "checkout " pasa lo siguiente y veremos que hay un commit apuntando hacia ella , tambien lo que sucedio es que 
HEAD cambio de posision a otra rama , es decir no es que los datos hayan cambiado , es que HEAD cambio de posicion y la segunda y ultima que hizo fue 
copiar los datos actuales tanto al area de trabajo como a index , asi que las tres areas tiene el mismo contenido , y esto sucede porque head se mueve a otra rama
copia datos del repositorio de trabajo , al index , ESTAMOS RESPONDIENDO LAS DOS PREGUNTAS PRINCIPALES DE COMO FUNCIONA GIT .

ELIMIANR ARCHIVOS 

podemor crear nuevos archivos , y al mirar git status veremos que  pide agregarlo al indice , lo podemos confirmar para agregarlo pero git no sabe aun que hacer con el 
al mirar nos va arrojar que el archivo es new file , el archivo se encuentra entre el area de trabajo y el indice , pero no esta en el repositorio , todavia no es una parte 
oficial del proyecto ,podriamos agregarlo al repositorio , pero que pasa si  nos arrepentimos y no queremos agregarlo y lo queremos eliminar del index y lo que queremos es 
hacer algo en ese archivo y volver a el mas tarde , en otras palabras quiero al archivo en el lugar de trabajo pero no en el index, 
por lo que podriamos usar el comando  "git rm --cached nombre de archivo " y nos va a eliminar la copia del archivo en el index 

CAMBIO DE NOMBRES DE ARCHIVOS 

Veamos la diferencia entre mover y renombrar archivos , basicamente es lo mismo la diferencia es que
al yo tener un archivo tanto en el lugar de trabajo como en index y el repositorio, y cambio el nombre del archivo 
en el lugar de trabajo , pero en index y el repositorio seguiran con el mismo nombre .

al mirar con git status nos mostrar el nombre del archivo que se elimino y otro que esta pendiente por agregar , como le podemos decir a git 
que es el mismo archivo pero solo con nombre diferente , la buena noticia es que no necesitamos hacer eso , lo que debemos hacer es lo siguiente
-git add nombre del nuevo archivo
-git add nombre del archivo que se elimino , esto es para sobreescribir los datos y como hay un archivo en el lugar de trabajo que no es del mismo nombre
eliminara el anterior automaticamente dejando el nuevo .

al pedir el estado "git status " nos mostrara que los archivos fueron renombrados , esto funciona tanto para nombrar como para mover archivos
al confirmar , automaticamente el archivo pasa al repositorio con el nuevo nombre , git rastrea los movimientos y cambios de nombre automaticamente 

LAS CUATRO AREAS DE GIT RESET 

entendiendo git reset 

es normal utilizar git reset par un reinicio debemso estar familiarizados en entender como funciona el area de trabajo, el index, y el repositorio 
para poder entender como funsiona reset , ya que tiene diferentes casos de usos .

cuantos comando git sabemos que mueve una rama que son :

-commit
-merge
- rebase
-git pull: obtiene nuevas confirmaciones de un control remoto actualiza las ramas locales y remotas 

lo importante para hacer el reinicio es entender que es lo que hace el reinicio a el area de trabajo y el index 

si se le da la opcion --hard restablece los datos de la copia del nuevo commit acitual , tanto al area de trabajo como al index
con la opcion --mixed restablece los datos actuales al index pero deja solo el area de trabajo 
con la opcion --soft significa no tocar ninguna de estas dos ares , simplemente mueva las ramas y omita el paso 2 por completo .

esto es lo que hace reset , primero mueva la rama actual por lo que tambien cambia la confirmacion actual 
segundo copia los archivos y directorios del nuevo commit actual al area de trabajo y al siguiente 

UN EJEMPLO DE REINICIO 

estamos en las rama master verificamos y todo los datos estan en los tres lados , estando en el repositorio 
 observaremos la confirmacion actual .

 tengo un commit que contiene versiones de archivos y queremos que ese commit sea el ultimo 
 entonces lo que haces es lo siguiente escribimos el comando seguido del numero del commit

 git reset numero del commit , esto hara que la rama retroceda en el tiempo , las opciones para restablecer se trata de 
 un restablecimiento parcial o un restablecimiento mixto 

 para restablecer de una forma completa lo que podemos hacer es para estar limpios otra vez es 

 -git reset --hard nombre de la rama en la que queremos estar , lo que hace git es arrastrar los archivos que tenemos en esa rama 
 y copiarlos tanto en el repositorio como index y lugar de trabajo .

 MAS EJEMPLOS DE REINICIO 

 Que pasa si agregue algo al index pero no estoy seguro de confirmarlos y quiero que permanezcan en el area de trabajo primero 
 podemos utilizar un reinicio en HEAD que seria el siguiente -git reset HEAD , esto quiere decir que estamos moviendo la rama actual al commit señalado 
 por HEAD , pero la rama actual ya esta apuntando , el resultado es que destabiliza los cambios volviendo los datos al repositorio , el archivo 
 aparecera en rojo pero no queremos agregarlo , en este caso lo que podemos hacer es 
 -git reset --hard HEAD hay que tener cuidado con este comando ya que es una de las formas mas destructivas que pueden haber , 

LAS CUATRO AREAS HERRAMIENTAS AVANZADAS 

Almacenamiento de Datos 

hablaremos de la cuarta area donde se almacenan los datos que se llama stash , si queremos que algo suceda en el stash debemos ser muy explicitos al respecto 
los datos en stash no cambian a menos que lo desiemos , ya que todos los cambios quedan alojados en stash 

-git stash --include-untracked esto significa almacenar archivos que aun no se han rastreado , guardado , arcivos que son completamente nuevos en el area de trabajo 
git toma todos los tados que hay en el area de trabajo y el index , y los copia pasandolos al stash y luego verifica el repositorio pasando esos datos tambien ,
nuestros archivos han desaparecido tanto del area de trabajo como del index , no se han ido por supuesto , estan en estash , y podemos ver el contenido con 

-git stash list , y lo podemos ver, todo el trabajo empaquetado que optiene un id de serie, que se puede denotar al principio 
esto nos sirve para tener un trabajo medio hacer , pero permanecera en un escondite , luego de hacer todo el trabajo que queremos y lo terminamos podemos recuperar todas las
cosas que escondimos .

-git stash aplly , nos aparecera en rojo , los elementos en el area de trabajo lo mismo pasa si los tenemos al principio y todavia no queremos agregarlos ni confirmarlos 
tambien podemos eliminar algo del stash - git stash clear 

RESOLVER CONFLICTOS 

Los conflictos de una fusion , en la vida real podemos tener conflictos , al fusionar una rama con la otra por lo general se presentan conflictos 
y aparecen muchas veces de la siguiente manera .

<<<<<<<HEAD
=======
>>>>>>>

Git no puede decidir cual de estos cambios vienen primero o si uno de estos cambios debe sobreescribir al otro , esto es lo que afecta las cuatro AREAS
una pregunta que surge es como sabe el comando git status que estamos en medio de una fusion y que hay un conflicto en este archivo , bueno lo sabe porque 
el comando de fusion creo algunos archivos en el directorio .git

lo primero es arreglar el conflicto y decidir como iran estos cambios en el archivo , cuando lo resolvemos debemos usar el index para decirle a git que informacion va a la proxima confirmacion 
-git add 
git commit , git nos muestra automaticamente que se soluciono el problema y se compromete 

TRABAJAR CON RUTAS 

Tenemos un archivo el cual modificamos , lo agregamos esta en index pero lo que remos restablecer 
-git reset HEAD nombre del archivo , esto sirve para restablecer un archivo que ya esta comprometido , y vuelve al index
-git checkout HEAD nombre del archivo , esto nos sirve para trabajar sin tocar otros achivos , asi que perdimo todos los cambios que le hicimos a ese archivo 

CONFIRMACION DE PARTES DE UN ARCHIVO 

Los atomos son un buen modelo para describir como es git , funciona en archivos y directorios , y ese atomo se puede dividir 
tenemos una rama , dentro de esa rama tenremos un archivo al cual le hemos añadido informacion 
digamos que algunos de los cambios que acabamos de realizar los queremos confirmar de inmediato y los otros confirmarlos mas adelante en un compromiso por separado 
pero como lo hacemos si los datos pertenecen al mismo archivo .
-git add --patch nombre del archivo , aca miraremos lo que pasa git mira los cambios que se hicieron y los divide en secciones llamados trozos y para cada trozo da una serie de 
opciones , al dificil es de entender pero uno de ellos es el signo de ? que nos proporciona documentacion para las otras opciones 
cuando los datos estan todos juntos , git lo toma todo como un solo trozo , debemos pedirle a gir que divida este trozo 
en trozos mas pequeños .

podemos ir saltando entre trozos para escoger cual es el que queremos confirmar entonces lo podremos hacer 
al volver y verificar con git status, nos arrojara que el archivo tiene datos pendientes por confirmar ,pero estos datos no los queremos confirmar todavia en el index

PRESENTAMOS GIT Y RESTORE 
